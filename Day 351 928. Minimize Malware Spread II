import java.util.*;

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] infected = new boolean[n];
        for (int x : initial) infected[x] = true;

        DSU dsu = new DSU(n);
        for (int i = 0; i < n; i++) {
            if (infected[i]) continue;
            for (int j = i + 1; j < n; j++) {
                if (infected[j]) continue;
                if (graph[i][j] == 1) dsu.union(i, j);
            }
        }

        int[] compSize = new int[n];
        for (int i = 0; i < n; i++) {
            if (!infected[i]) compSize[dsu.find(i)]++;
        }

        int[] touchCount = new int[n];
        List<int[]> touches = new ArrayList<>();
        for (int src : initial) {
            HashSet<Integer> seen = new HashSet<>();
            for (int v = 0; v < n; v++) {
                if (!infected[v] && graph[src][v] == 1) {
                    int r = dsu.find(v);
                    if (seen.add(r)) {
                        touchCount[r]++;
                        touches.add(new int[]{src, r});
                    }
                }
            }
        }

        int[] saved = new int[n];
        for (int[] p : touches) {
            int src = p[0], r = p[1];
            if (touchCount[r] == 1) saved[src] += compSize[r];
        }

        Arrays.sort(initial);
        int ans = initial[0];
        int best = -1;
        for (int x : initial) {
            if (saved[x] > best) {
                best = saved[x];
                ans = x;
            }
        }
        return ans;
    }

    static class DSU {
        int[] p, r;
        DSU(int n) {
            p = new int[n];
            r = new int[n];
            for (int i = 0; i < n; i++) p[i] = i;
        }
        int find(int x) {
            while (p[x] != x) {
                p[x] = p[p[x]];
                x = p[x];
            }
            return x;
        }
        void union(int a, int b) {
            int pa = find(a), pb = find(b);
            if (pa == pb) return;
            if (r[pa] < r[pb]) p[pa] = pb;
            else if (r[pa] > r[pb]) p[pb] = pa;
            else { p[pb] = pa; r[pa]++; }
        }
    }
}
